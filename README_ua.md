# SherLog

<img src="logo.svg" alt="logo" width="300"/>

### Опис
SherLog — це легковагова бібліотека на **Golang**, що надає зручний та наочний спосіб трейсингу (відстеження) змін та дій над сутностями в системі. За допомогою неї можна логувати:
- Що відбулося із сутністю;
- Коли і де саме це відбулося (в якому сервісі, процесі, компоненті, або гілці логіки);
- Та в якому контексті, прикріпляючи додаткові параметри та мітки/теги.

SherLog створена для того, щоб швидко і просто отримати "шлях" виконання та деталі змін над сутностями, що особливо корисно при дебагінгу, аудиті, або трасуванні складних процесів у мікросервісній архітектурі.

Приклад виводу логу в терміналі:
```
╭─[18:33:42]─( user : 54 )─{ order_service_3 >> post_order_API > DB_repo > AddUser }
╰─[ INFO ]─> User added
  ╰─> name: Juster
  ╰─> age: 26
```

Короткий формат:
```
[18:33:42]─[ INFO ]─( user : 54 )─{ AddUser }─> User added
```

### Ініціалізація

На початку роботи з бібліотекою потрібно її ініціалізувати, викликавши функцію `sherlog.Init()` та передав їй в якості параметрів структури конфігурації і фільтру логів (якщо фільтр не потрібний, можна передати `nil`):
```go
sherlog.Init(sherlog.Config{}, &sherlog.Filter{})
```
Бібліотека ініціалізується лише при першому виклику, послідуючі виклики **ігноруються та не викликають помилки/паніки**.

Поля конфігурації:
```go
type Config struct {
    Level           byte   // рівень логування (від 0 до 7)
    SyncPrint       bool   // синхронний вивід логів
    NotShowLogs     bool   // не виводити логи

    NotShowDatetime bool   // не виводити дату і час
    ShowDate        bool   // виводити дату
    ShowTimeDelta   bool   // виводити дельту часу між логами
    NotShowLevel    bool   // не виводити рівень логування
    NotShowTraces   bool   // не виводити ланцюг трейсів
    NotShowModules  bool   // не виводити ланцюг модулів
    NotShowEntity   bool   // не виводити сутність
    NotShowEntityId bool   // не виводити ID сутності
    NotShowLabels   bool   // не виводити мітки/теги
    NotShowFields   bool   // не виводити додаткові поля
    ShortMode       bool   // короткий вивід логів

    LogsDir         string // шлях до папки, в яку будуть зберігатися логи (якщо не залишити дане поле пустим, то логи не будуть записуватися на диск)
    AutodumpAfter   int    // кількість логів в буфері, після якого відбувається запис логів на диск (можна вказати значення 0, для заборони автоматичного запису логів та залишити лише ручне)
}
```

Фільтр дозволяє створювати всі логи, окрім тих, що входять до фільтру. Фільтрувати можна за наступними полями:
```go
type Filter struct {
    Traces   []string          // за трейсами
    Modules  []string          // за модулями
    Entities []string          // за сутностями
    Labels   []string          // за мітками
    Fields   map[string]string // за ключ-значеннями в додаткових полях
    Invert   bool              // якщо вказати "true", то логи будуть створюватися навпаки лише ті, які входять до фільтру
}
```

### Початок трейсингу

Для відстеження логіки виконання у SherLog використовується структура `sherlog.Trace`. Вона дозволяє створити ланцюг подій, який описує потік виконання певного процесу/горутини.

Для початку трейсингу потрібно створити структуру `Trace` та вказати ім'я поточного процесу/горутини:
```go
trace := sherlog.NewTrace("some_process")
```
Структура `Trace` відповідає одному процесу/потоку/горутині, тобто відстежує потік дій саме в ньому, тому структура **не потоко-безпечна**, так как як призначена для синхронної роботи.

Якщо виникає ситуація, коли один процес переходить в інший, то для цього можна викликати метод `Fork()`, вказавши ім'я нового процесу, метод здійснить копію структури `Trace` із доданим новим процесом в ланцюзі, і цей трейс уже можна використовувати в іншому процесі паралельно. Або для випадку розгалуження, підійде метод `ForkOnMap(name ...string)`, який здійснить декілька копій трейсу під передані йому ключі (ключі також будуть використовуватися як імена процесів):
```go
main_trace := sherlog.NewTrace("main_trace")
main_trace.TraceChain()  // main_trace

child_trace := main_trace.Fork("child_trace")
child_trace.TraceChain() // main_trace > child_trace

traces := child.ForkOnMap("trace_1", "trace_2", "trace_3")
traces["trace_1"].TraceChain() // main_trace > child_trace > trace_1
traces["trace_2"].TraceChain() // main_trace > child_trace > trace_2
traces["trace_3"].TraceChain() // main_trace > child_trace > trace_3
```
Після використання трейсу (наприклад горутина завершила роботу і трейс вже не потрібний) потрібно його закрити, викликав метод `Close()`, аби уникнути витоку ресурсів. Або викликати функцію `sherlog.CloseTraces(map[string]*Trace)`, яка приймає словник з трейсами та закриває їх.

Потім в трейсі можна вказати клас та ID сутності, яка висліджується, за допомогою метода `SetEntity(name, id string)`. Наприклад якщо потрібно відстежити користувача з ID 5, або задачу з ID 35a4f6, то це буде виглядати так:
```go
trace1.SetEntity("user", "5")
trace2.SetEntity("task", "35a4f6")
```

### Модулі

Для того щоб указати звідки був надісланий лог (з якого мікросервісу, класу, функції, тощо), до трейсу можна додавати модулі викликаючи метод `AddModule(group, module string)`, створюючи ланцюги з модулів. Робиться це наступним чином:
```go
popModule1 := trace.AddModule("", "module_1")
trace.INFO(nil, "message") // лог матиме ланцюг: module_1

popModule2 := trace.AddModule("", "module_2")
trace.INFO(nil, "message") // лог матиме ланцюг: module_1 > module_2

popModule1()               // видалення модулів з трейсу
popModule2()
trace.INFO(nil, "message") // лог не матиме ланцюгу
```
В такому разу всі відіслані логи з даного трейсу після додавання модулю, матимуть його в своєму ланцюгу, вказуючи на місце звідки вони прийшли. `popModule()` це callback функція, яка видаляє доданий модуль з трейсу, тобто додавання і видалення модулю можна записати в один рядок використовуючи `defer`, якщо ми знаходимося в функції:
```go
func fn() {
    defer trace.AddModule("", "some_module")()
    trace.INFO(nil, "message")
}
```
Ще є спосіб додавання модуля через метод `WithModule()`, передаючи йому функцію, в межах якої логи матимуть вказаний модуль:
```go
trace.WithModule("", "some_module", func() {
    trace.INFO(nil, "message")
})
```
Іноді модулі можуть бути вкладеними або бути частиною іншого модуля. Наприклад, якщо метод класу (структури) викликає інший метод того ж класу, при чому і клас, і метод це все модулі, то щоб не мати дублікатів в ланцюгу (`class > method_1 > class > method_2`), модулі можно згрупувати:
```go
type Class struct{
    Trace *sherlog.Trace
}

func (c *Class) Method_1() {
    defer c.Trace.AddModule("class", "method_1")()
    c.Trace.INFO(nil, "message") // матиме ланцюг: service > class > method_1
    c.method_2()
}

func (c *Class) method_2() {
    defer c.Trace.AddModule("class", "method_2")() // трейс вже знаходится в групі "class", тому вона ігнорується і не дублюється в ланцюгу
    c.Trace.INFO(nil, "message") // матиме ланцюг: service > class > method_1 > method_2
}

func main() {
    sherlog.Init(sherlog.Config{}, nil)
    trace := sherlog.NewTrace("main_trace")
    defer c.Trace.AddModule("", "service")()

    c := &Class{Trace: trace}
    c.Method_1()
}
```
Трейс порівнює вказану групу з поточною, і якщо вони не співпадають, то вказана група додається як новий модуль, інакше ігнорує її запобігаючи дупліката.
Якщо передати пустий рядок замість групи, це означатиме, що модуль не має групи, і буде доданий тільки сам модуль.

### Логи

Для того щоб створити лог, потрібно викликати один із наступних методів логування в трейсі. Кожен метод відповідає певному рівню важливості повідомлення:
- `FATAL()` (рівень 7, Fatal) - критична помилка, після якої неможливо продовжити роботу (після виклику відбувається запис логів на диск (якщо це дозволено) та завершення роботи програми через `os.Exist(1)`);
- `ERROR()` (рівень 6, Error) - серйозна помилка, але після якої ще можливо продовжувати роботу;
- `WARN()` (рівень 5, Warning) - попередження про аномальну або не очікувану поведінку;
- `INFO()` (рівень 4, Information) - звітування про дії програми в процесі її виконання, або операції над сутністю, яка відстежується. Не є технічною інформацією, тобто це логи для простих користувачів, аналітиків, DevOps, тощо;
- `NOTE()` (рівень 3, Note) - корисна загальна інформація (більше для аналітики), наприклад помилки вводу користувачів, помилки валідації, деякі події та інше;
- `STAGE()` (рівень 2, Stage) - ключові етапи роботи програми або операції над сутністю;
- `DEBUG()` (рівень 1, Debug) - технічні деталі для розробника;
- `MICRO()` (рівень 0, Micro) - подробиці виконання програми, наприклад для опису значень змінних на кожній ітерації циклу.

Тобто рівні можна умовно згрупувати таким чином: 0-2 для розробників, 3-4 для користувачів, 5-7 це помилки.

В метод можна передати атрибут (або залишити `nil`, якщо він не потрібний) і набір аргументів для формування повідомлення:
```go
num := 5
msg := "do abcd"
trace.INFO(nil, "Task number ", num, " -> message: ", msg) // "Task number 5 -> message: do abcd"
```

Також є умовні методи з приставками `*_if_err` та `*_if_not_error`, які створюють лог тільки якщо є або не має помилки (помилка передається як параметр):
```go
err := errors.New("some error")
trace.DEBUG_if_not_err(err, nil, "message") // не створить лог, так як є помилка
err = nil
trace.ERROR_if_err(err, nil, "message")     // не створить лог, так як помилки вже немає
```

### Атрибути

В атрибутах логів можна передати наступне:
- Мітки/теги (`sherlog.Labels`) - це слайс із рядків, за якими можна групувати логи:
```go
trace.NOTE(sherlog.Labels{"auth", "user error"}, "Incorrect password")
```
- Додаткові поля (`sherlog.Fields`) - це словник з додатковою інформацією, в якій ключ та значення є рядками:
```go
trace.INFO(sherlog.Fields{"name": "Juster", "age": "26"}, "User created")

// Або через функцію, яка конвертує ключі та значення в рядки використовуючи fmt.Sprint
trace.DEBUG(sherlog.WithFields("ID", 5, "is private": true), "Task added")
```
- Групу атрибутів (`sherlog.Attr`) - тобто і мітки, і теги разом:
```go
trace.INFO(&sherlog.Attr{
    Labels: sherlog.Labels{"auth", "customer"},
    Fields: sherlog.Fields{
        "name": "Maria",
        "age": "23",
    },
}, "User created")
```

### Додатково

Формат виводу логу із всіма блоками терміналі виглядає так:
```
╭─[26.03.2025 18:33:42 +10ms]─( entity : id )─{ trace1 > trace2 >> module1 > module2 }─(label1, label2)
╰─[ INFO ]─> Some message
  ╰─> key1: val1
  ╰─> key2: val2
```
Або короткий формат:
```
[26.03.2025 18:33:42 +10ms]─[ INFO ]─( entity : id )─{ module2 }─> Some message
```

- По завершенню роботи програми потрібно викликати функцію `sherlog.Close()` щоб корректно завершити роботу трейсів і записати логи з буферу на диск (якщо це дозволено);
- Можна вручну записати логи які є в буфері викликав функцію `sherlog.DumpLogs()`;
- Логи зберігаються як об'єкти JSON в файли формату "*26.03.2025.log*", тобто логи будуть групуватися по днях, що полегшує агрегацію та архівацію логів.